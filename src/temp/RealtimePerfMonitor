
package components;

import com.vmware.vim25.PerfCounterInfo;
import com.vmware.vim25.PerfEntityMetricBase;
import com.vmware.vim25.PerfEntityMetricCSV;
import com.vmware.vim25.PerfMetricId;
import com.vmware.vim25.PerfMetricSeriesCSV;
import com.vmware.vim25.PerfProviderSummary;
import com.vmware.vim25.PerfQuerySpec;
import com.vmware.vim25.mo.ManagedEntity;
import com.vmware.vim25.mo.PerformanceManager;
import com.vmware.vim25.mo.ServiceInstance;
import com.vmware.vim25.mo.VirtualMachine;


public class RealtimePerfMonitor {
	public static void printStats(ServiceInstance si, VirtualMachine vm, CounterIDCounterInfoMapper ccm) throws Exception {
	    
		PerformanceManager perfMgr = si.getPerformanceManager();
		
		// find out the refresh rate for the virtual machine
		PerfProviderSummary pps = perfMgr.queryPerfProviderSummary(vm);
		int refreshRate = pps.getRefreshRate().intValue();
		
		// retrieve all the available perf metrics for vm
		PerfMetricId[] pmis = perfMgr.queryAvailablePerfMetric(vm, null, null, refreshRate);
		
		PerfQuerySpec qSpec = createPerfQuerySpec(vm, pmis, 3, refreshRate);
		
		/**
		 * Cycle through the PerfEntityMetricBase objects. Each object contains
		 * a set of statistics for a single ManagedEntity.
		 **/

		PerfEntityMetricBase[] retrievedStats = perfMgr.queryPerf(new PerfQuerySpec[] {qSpec});
		
		
		for(PerfEntityMetricBase singleEntityPerfStats : retrievedStats) {
			/*
			 * Cast the base type (PerfEntityMetricBase) to the csv-specific sub-class.
			 */
			PerfEntityMetricCSV entityStatsCsv = (PerfEntityMetricCSV)singleEntityPerfStats;
			/* Retrieve the list of sampled values. */
			PerfMetricSeriesCSV[] metricsValues = entityStatsCsv.getValue();
			if(metricsValues == null) {
				System.out.println("No stats retrieved. " + "Check whether the virtual machine is powered on.");
				throw new Exception();
			}
		
		
			/**
			 * Cycle through the PerfMetricSeriesCSV objects. Each object contains
			 * statistics for a single counter on the ManagedEntity.
			 **/
			for(PerfMetricSeriesCSV csv : metricsValues) {
				/*
				 * Use the counterId to obtain the associated PerfCounterInfo object
				 */
				PerfCounterInfo pci = ccm.get(csv.getId().getCounterId());
				/* Print out the metadata for the counter. */
				System.out.println("----------------------------------------");
				System.out.println(pci.getGroupInfo().getKey() + "." + pci.getNameInfo().getKey() + "." + pci.getRollupType() + " - " + pci.getUnitInfo().getKey());
				System.out.println("Instance: "+csv.getId().getInstance());
				System.out.println("Values: " + csv.getValue());
			}
		}
		
	  }
	
	  static PerfQuerySpec createPerfQuerySpec(ManagedEntity me, PerfMetricId[] metricIds, int maxSample, int interval) {
	    PerfQuerySpec qSpec = new PerfQuerySpec();
	    qSpec.setEntity(me.getMOR());
	    // set the maximum of metrics to be return
	    // only appropriate in real-time performance collecting
	    qSpec.setMaxSample(new Integer(maxSample));
	    qSpec.setMetricId(metricIds);
	    // optionally you can set format as "normal"
	    qSpec.setFormat("csv");
	    // set the interval to the refresh rate for the entity
	    qSpec.setIntervalId(new Integer(interval));
	 
	    return qSpec;
	  }
}